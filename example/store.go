// Code generated by norm. DO NOT EDIT.
// Generated on: 2020-12-26 18:50:49.673523925 -0800 PST m=+0.002477716
package example

import (
	"database/sql"
)

type GetUserListNoModelResult struct {
	stmt *sql.Stmt
	rows *sql.Rows
}

func (res GetUserListNoModelResult) Next() bool {
	return res.rows.Next()
}

func (res GetUserListNoModelResult) Scan(ID *int, Email *string) error {
	return res.rows.Scan(ID, Email)
}

func (res GetUserListNoModelResult) Close() {
	if res.rows != nil {
		res.rows.Close()
	}
	if res.stmt != nil {
		res.stmt.Close()
	}
}

// Retrieves all emails from the users table. Since there is no// intermediate model, an output struct is autocreated which will contain only// the fields specified in the output. Please make sure that the field names// are capitalized.
func GetUserListNoModelScan(db *sql.DB) (*GetUserListNoModelResult, error) {
	result := GetUserListNoModelResult{}
	var err error
	result.stmt, err = db.Prepare(`SELECT id, email
FROM user
ORDER BY email ASC`)
	if err != nil {
		return nil, err
	}
	result.rows, err = result.stmt.Query()
	if err != nil {
		defer result.stmt.Close()
		return nil, err
	}
	return &result, nil
}

type GetUserListNoModelOutput struct {
	ID    int
	Email string
}

func GetUserListNoModel(db *sql.DB) ([]GetUserListNoModelOutput, error) {
	res, err := GetUserListNoModelScan(db)
	if err != nil {
		return nil, err
	}
	defer res.Close()
	var ret []GetUserListNoModelOutput
	for res.Next() {
		var o GetUserListNoModelOutput
		if err := res.Scan(&o.ID, &o.Email); err != nil {
			return ret, err
		}
		ret = append(ret, o)
	}
	return ret, nil
}

type GetUserEmailsNoModelResult struct {
	stmt *sql.Stmt
	rows *sql.Rows
}

func (res GetUserEmailsNoModelResult) Next() bool {
	return res.rows.Next()
}

func (res GetUserEmailsNoModelResult) Scan(Email *string) error {
	return res.rows.Scan(Email)
}

func (res GetUserEmailsNoModelResult) Close() {
	if res.rows != nil {
		res.rows.Close()
	}
	if res.stmt != nil {
		res.stmt.Close()
	}
}

// Retrieves all emails from the users table. In this example, there is// only one output field. Therefore an intermediate struct is also not needed,// we just return a slice of the output type (string in this case)
func GetUserEmailsNoModelScan(db *sql.DB) (*GetUserEmailsNoModelResult, error) {
	result := GetUserEmailsNoModelResult{}
	var err error
	result.stmt, err = db.Prepare(`SELECT email
FROM user
ORDER BY email ASC`)
	if err != nil {
		return nil, err
	}
	result.rows, err = result.stmt.Query()
	if err != nil {
		defer result.stmt.Close()
		return nil, err
	}
	return &result, nil
}

func GetUserEmailsNoModel(db *sql.DB) ([]string, error) {
	res, err := GetUserEmailsNoModelScan(db)
	if err != nil {
		return nil, err
	}
	defer res.Close()
	var ret []string
	for res.Next() {
		var o string
		if err := res.Scan(&o); err != nil {
			return ret, err
		}
		ret = append(ret, o)
	}
	return ret, nil
}

type GetUserListWithModelResult struct {
	stmt *sql.Stmt
	rows *sql.Rows
}

func (res GetUserListWithModelResult) Next() bool {
	return res.rows.Next()
}

func (res GetUserListWithModelResult) Scan(ID *int, Email *string) error {
	return res.rows.Scan(ID, Email)
}

func (res GetUserListWithModelResult) Close() {
	if res.rows != nil {
		res.rows.Close()
	}
	if res.stmt != nil {
		res.stmt.Close()
	}
}

// Retrieves all emails from the users table. In this example, an// intermediate model is used. See `gen.go` for the model definition. This// allows users to specify an arbitrary intermediate struct.
func GetUserListWithModelScan(db *sql.DB) (*GetUserListWithModelResult, error) {
	result := GetUserListWithModelResult{}
	var err error
	result.stmt, err = db.Prepare(`SELECT id, email
FROM user
ORDER BY email ASC`)
	if err != nil {
		return nil, err
	}
	result.rows, err = result.stmt.Query()
	if err != nil {
		defer result.stmt.Close()
		return nil, err
	}
	return &result, nil
}

func GetUserListWithModel(db *sql.DB) ([]User, error) {
	res, err := GetUserListWithModelScan(db)
	if err != nil {
		return nil, err
	}
	defer res.Close()
	var ret []User
	for res.Next() {
		var o User
		if err := res.Scan(&o.ID, &o.Email); err != nil {
			return ret, err
		}
		ret = append(ret, o)
	}
	return ret, nil
}

// Add a user to the DB
func AddUser(db *sql.DB, email string) error {
	stmt, err := db.Prepare(`INSERT into user(email)
VALUES ($1)`)
	if err != nil {
		return err
	}
	defer stmt.Close()
	_, err = stmt.Exec(email)
	if err != nil {
		return err
	}
	return nil
}

// Deletes all users from the DB
func DeleteAllUsers(db *sql.DB) error {
	stmt, err := db.Prepare(`DELETE FROM user`)
	if err != nil {
		return err
	}
	defer stmt.Close()
	_, err = stmt.Exec()
	if err != nil {
		return err
	}
	return nil
}

type FindUserOutput struct {
	ID    int
	Email string
}

// Finds user by email
func FindUser(db *sql.DB, email string) (*FindUserOutput, error) {
	stmt, err := db.Prepare(`SELECT id, email
FROM USER
WHERE email = $1`)
	if err != nil {
		return nil, err
	}
	defer stmt.Close()
	var o FindUserOutput
	if err = stmt.QueryRow(email).Scan(&o.ID, &o.Email); err != nil {
		return nil, err
	}
	return &o, nil
}

// Finds user by email.
func FindUserEmail(db *sql.DB, email string) (*string, error) {
	stmt, err := db.Prepare(`SELECT email
FROM USER
WHERE email = $1`)
	if err != nil {
		return nil, err
	}
	defer stmt.Close()
	var o string
	if err = stmt.QueryRow(email).Scan(&o); err != nil {
		return nil, err
	}
	return &o, nil
}

// Creates the user table
func CreateUserTable(db *sql.DB) error {
	stmt, err := db.Prepare(`CREATE TABLE user (
	id integer primary key autoincrement,
	email text
)`)
	if err != nil {
		return err
	}
	defer stmt.Close()
	_, err = stmt.Exec()
	if err != nil {
		return err
	}
	return nil
}
